import ast
from _ast import AST
from ast import iter_fields
from pprint import pprint

from scope_tracker import ScopeTracker
from symbol_pass import SymbolPass

INDENT_STEP = 4

DEBUG_SHOW_NODES = True

binop_to_string_dict = {
    ast.Add: "+",
    ast.Sub: "-",
    ast.Mult: "*",
    ast.Div: "/",
    ast.Lt: "<",
    ast.Gt: ">",
    ast.LtE: "<=",
    ast.GtE: ">=",
    ast.Eq: "==",
    ast.NotEq: "!=",
    ast.Mod: "%",
    ast.BitOr: "|",
    ast.BitAnd: "&",
    ast.BitXor: "^",
    ast.LShift: "<<",
    ast.RShift: ">>",
}

boolop_to_string_dict = {
    ast.And: "and",
    ast.Or: "or",
    ast.Not: "not",
}

python_type_to_c_type = {
    "int": "int",
    "float": "double",
    "str": "String",
    "bool": "bool",
    "void": "void",
}

# scoped-symbol:
# <func/class>::<symbol>

MODULE_HEADING = """/* Generated by PyToC Translator */

#pragma GCC diagnostic ignored "-Wdeprecated"
#include <ArduinoSTL.h>

using namespace std;

"""


class GeneratePass(ScopeTracker):
    def __init__(self, symbols, tree, output_file, lines, headings=True):
        super().__init__(lines)
        self.syms = symbols
        self.indent_level = 0
        self.out_string = ""
        self.headings = headings
        self.outf = output_file

        # Local context stuff
        self.current_target = None  # hold assignment target during eval
        self.num_arguments = 0
        self.during_assign = False
        self.already_emitted_initializer = {}

        # Run the tree
        self.visit(tree)

    def initializer_emitted(self, scoped_sym):
        return scoped_sym in self.already_emitted_initializer

    def mark_initialized(self, scoped_sym):
        self.already_emitted_initializer[scoped_sym] = True

    def boolop_to_string(self, obj_or_class):
        ret = boolop_to_string_dict.get(obj_or_class, None)
        if ret is None:
            return boolop_to_string_dict[obj_or_class.__class__]

    def binop_to_string(self, obj_or_class):
        ret = binop_to_string_dict.get(obj_or_class, None)
        if ret is None:
            ret = binop_to_string_dict.get(obj_or_class.__class__, None)
        if ret is None:
            raise self.exception(f"Unsupported binary operator {obj_or_class}")
        return ret

    def indented(self, s):
        return " " * self.indent_level + s

    def output(self, s, indent=False):
        if indent and (len(self.out_string) == 0 or self.out_string[-1] == "\n"):
            if "\n" in s.rstrip("\n"):
                lines = [self.indented(x).rstrip() for x in s.splitlines()]
                line = "\n".join(lines)
                if len(s) > 0 and s[-1] == "\n":
                    line += "\n"
                self.out_string += line
            else:
                self.out_string += self.indented(s)
        else:
            self.out_string += s
        if len(self.out_string) > 0 and self.out_string[-1] == "\n":
            self.outf.write(self.out_string)
            self.out_string = ""

    def indent(self):
        self.indent_level += INDENT_STEP

    def outdent(self):
        if self.indent_level >= INDENT_STEP:
            self.indent_level -= INDENT_STEP

    def emit_list_decl(self, parts, symbol):
        assert len(parts) == 3
        elem_type = python_type_to_c_type[parts[2]]
        list_size = parts[1]
        self.output(f"{elem_type} {symbol}[{list_size}]", indent=True)
        scoped_tgt = self.scoped_sym(symbol)
        init_list = self.syms.initializer[scoped_tgt]
        if len(init_list) == 0:
            self.output(";\n")
        else:
            self.mark_initialized(scoped_tgt)
            self.output(" = { ")
            self.output(", ".join([str(self.visit(elem)) for elem in init_list]))
            self.output(" };\n")

    def emit_func_forward_decl(self, adv_type, symbol):
        parts = adv_type.split(":")
        ret_type = python_type_to_c_type[parts[1]]
        self.output(f"{ret_type} {symbol}(", indent=True)
        func_args = self.syms.find_function_args(self.scoped_sym(symbol)) or []
        for arg in func_args:
            delim = ", " if arg != func_args[-1] else ""
            self.emit_single_local_decl(arg, delimiter=delim)
        if len(func_args) == 0:
            self.output("void")
        self.output(");\n")

    def emit_advanced_decl(self, adv_type, symbol):
        if adv_type == "func":  # function with no known return type - emit void return
            adv_type = "func:void"
        parts = adv_type.split(":")
        selector = parts[0]
        if selector == "list":
            self.emit_list_decl(parts, symbol)
        elif selector == "func":
            self.emit_func_forward_decl(adv_type, symbol)
        else:
            raise self.exception(f"Unknown advanced type description {adv_type=}")

    def emit_single_local_decl(self, name, delimiter=";\n"):
        local_name = self.syms.unscoped_sym(name)
        local_type = self.syms.find_type(name, self.current_node)
        if ":" in local_type or local_type.startswith(
            "func"
        ):  # advanced types, like list:int etc.
            self.emit_advanced_decl(local_type, local_name)
        else:
            c_type = python_type_to_c_type[local_type]
            self.output(f"{c_type} {local_name}{delimiter}", indent=True)

    def emit_scope_local_decls(self):
        # Passing self.current_node into self.syms methods for exception handling
        local_syms = self.syms.find_local_syms(
            self.current_scope(), include_function_args=False
        )
        if len(local_syms) > 0 and self.current_scope() != "" and self.headings:
            self.output("/* Local Variable Declarations */\n", indent=True)
        for name in local_syms:
            self.emit_single_local_decl(name)
        if len(local_syms) > 0:
            self.output("\n")

    def handle_builtin_typecall(self, node):
        builtin = node.func.id
        if builtin == "str":
            return "String"
        elif builtin == "tuple":
            return "tuple"
        raise self.exception("Unhandled case")

    #
    # Visit Functions
    #

    def visit_Global(self, node):
        pass

    def visit_Module(self, node):
        if self.headings:
            self.output(MODULE_HEADING + "\n")
        self.emit_scope_local_decls()
        self.generic_visit(node)

    def visit_FunctionDef(self, node):
        # Passing node into self.syms methods for exception handling
        func_name = node.name
        ret_type = self.syms.find_ret_type(self.scoped_sym(func_name), node=node)
        c_ret_type = python_type_to_c_type[ret_type]
        self.output(f"\n{c_ret_type} {func_name}")
        self.enter_scope(func_name)
        self.indent()
        # Ugly hack to avoid seeing the return type again...
        keep_returns = None
        if node.returns is not None:
            keep_returns = node.returns
            node.returns = None
        self.generic_visit(node)  # visit all children of this node
        if keep_returns is not None:
            node.returns = keep_returns
        self.outdent()
        self.exit_scope(func_name)
        self.output("}\n\n\n")

    def visit_IfExp(self, node):
        s = "("
        s += self.visit(node.test)
        s += " ? "
        s += str(self.visit(node.body))
        s += " : "
        s += str(self.visit(node.orelse))
        s += ")"
        return s

    def visit_If(self, node):
        if self.current_scope() == "":
            raise self.exception(
                f"You should not put executable code outside of functions."
            )
        s = "if " + self.visit(node.test) + " {\n"
        self.output(s, indent=True)
        self.indent()
        s = ""
        for item in node.body:
            ret = self.visit(item)
            s = s if ret is None else s + str(ret)
        if len(s) > 0:
            self.output(s)
        self.outdent()
        if len(node.orelse) == 0:
            self.output("}\n", indent=True)
        else:
            if len(node.orelse) == 1 and isinstance(node.orelse[0], ast.If):  # elif
                self.output("} else ", indent=True)
                self.visit_If(node.orelse[0])
            else:
                self.output("} else {\n", indent=True)
                self.indent()
                s = ""
                for item in node.orelse:
                    ret = self.visit(item)
                    s = s if ret is None else s + str(ret)
                if len(s) > 0:
                    self.output(s)
                self.outdent()
                self.output("}\n", indent=True)

    def visit_For(self, node):
        if self.current_scope() == "":
            raise self.exception(
                f"You should not put executable code outside of functions."
            )
        target_var_name = node.target.id
        python_var_type = self.syms.find_type(self.scoped_sym(target_var_name))
        target_var_type = python_type_to_c_type[python_var_type]
        loop_list = node.iter.elts
        loop_list_len = len(loop_list)
        self.output("{\n", indent=True)
        self.indent()
        # Declare temp array
        self.output(
            f"{target_var_type} _temp_array[{loop_list_len}] = " + "{ ", indent=True,
        )
        for item in loop_list:
            value = self.visit(item)
            if python_var_type == "str":
                value = f"String({value})"
            self.output(f"{value}, ")
        self.output("};\n")
        # Declare index var
        self.output("int _temp_index;\n", indent=True)
        # Output the loop
        self.output(
            f"for (_temp_index = 0; _temp_index < {loop_list_len}; _temp_index++)"
            + " {\n",
            indent=True,
        )
        self.indent()
        self.output(f"{target_var_name} = _temp_array[_temp_index];\n", indent=True)
        s = ""
        for item in node.body:
            ret = self.visit(item)
            if ret is not None:
                s += str(ret)
        if len(s) > 0:
            self.output(s, indent=True)
        self.outdent()
        self.output("}\n", indent=True)
        self.outdent()
        self.output("}\n", indent=True)

    def visit_Compare(self, node):
        if len(node.comparators) != 1 or len(node.ops) != 1:
            raise self.exception(f"Only simple binary comparisons are supported")
        s = "(" + str(self.visit(node.left))
        op_s = self.binop_to_string(node.ops[0])
        s += f" {op_s} "
        s += str(self.visit(node.comparators[0])) + ")"
        return s

    def visit_BoolOp(self, node):
        op_s = self.boolop_to_string(node.op)
        ret = (
            "("
            + f" {op_s} ".join([str(self.visit(value)) for value in node.values])
            + ")"
        )
        return ret

    def visit_arguments(self, node):
        self.num_arguments = 0
        self.output("(")
        self.generic_visit(node)
        if self.num_arguments == 0:
            self.output("void")
        self.output(") {\n")
        self.emit_scope_local_decls()
        if self.headings:
            self.output("/* Main Code */\n", indent=True)

    def visit_arg(self, node):
        # Passing node into self.syms methods for exception handling
        s = ""
        if self.num_arguments > 0:
            s += ", "
        self.num_arguments += 1
        scoped_sym = self.scoped_sym(node.arg)
        scoped_typ = self.syms.find_type(scoped_sym, node=node)
        c_scoped_typ = python_type_to_c_type[scoped_typ]
        s += f"{c_scoped_typ} {node.arg}"
        return s

    def visit_AnnAssign(self, node):
        # Passing node into self.syms methods for exception handling
        self.during_assign = True
        target = node.target.id
        scoped_target = self.scoped_sym(target)
        known_type = self.syms.find_type(scoped_target, node=node)
        tgt_type = node.annotation.id
        assert known_type == tgt_type
        self.current_target = node.target
        value = self.visit(node.value)
        self.current_target = None
        if tgt_type == "str":
            if not isinstance(value, str):
                raise self.exception(
                    f"Assignment to {tgt_s} of {value=} which is not a string"
                )
        self.output(f"{target} = {value};\n", indent=True)
        self.during_assign = False

    def visit_Assign(self, node):
        # Passing node into self.syms methods for exception handling
        self.during_assign = True
        targets = node.targets
        tgt_type = self.syms.find_type(self.scoped_sym(targets[0].id), node=node)
        tgt_names = []
        for target in targets:
            tgt_name = target.id
            scoped_tgt = self.scoped_sym(tgt_name)
            if self.initializer_emitted(scoped_tgt):
                return
            assert self.syms.find_type(scoped_tgt, node=node) == tgt_type
            tgt_names.append(target.id)
        tgt_s = " = ".join(tgt_names)
        self.current_target = target.id
        value = self.visit(node.value)
        self.current_target = None
        if tgt_type == "str":
            if not isinstance(value, str):
                raise self.exception(
                    f"Assignment to {tgt_s} of {value=} which is not a string"
                )
        self.output(f"{tgt_s} = {value};\n", indent=True)
        self.during_assign = False

    def visit_Return(self, node):
        if node.value is None:
            self.output("return;\n", indent=True)
            return
        s = "return ("
        s += str(self.visit(node.value))
        s += ");\n"
        self.output(s, indent=True)

    def visit_Constant(self, node):
        if isinstance(node.value, str):
            if '"' in node.value:
                ret = node.value.replace('"', '\\"')
            if self.during_assign:
                return f'String("{node.value}")'
            else:
                return f'"{node.value}"'
        elif isinstance(node.value, bool):
            return str(node.value).lower()
        else:
            return node.value

    def visit_List(self, node):
        s = "["
        first = True
        for elem in node.elts:
            if first:
                first = False
            else:
                s += ", "
            s += str(self.visit(elem))
        s += "]"
        return s

    def visit_Tuple(self, node):
        return self.visit_List(node)

    def visit_Name(self, node):
        return node.id

    def visit_Load(self, node):
        self.generic_visit(node)

    def visit_Expr(self, node):
        was_docstring = self.generic_visit(node)
        if not was_docstring:
            self.output(";\n")

    def visit_BinOp(self, node):
        left = self.visit(node.left)
        op_s = self.binop_to_string(node.op)
        right = self.visit(node.right)
        return f"({left} {op_s} {right})"

    def visit_UnaryOp(self, node):
        s = self.visit(node.operand)
        if isinstance(node.op, ast.USub):
            s = f"-{s}"
        elif isinstance(node.op, ast.Not):
            s = f"!{s}"
        return s

    def visit_Index(self, node):
        return str(self.visit(node.value))

    def visit_Call(self, node):
        is_string = False
        is_list = False
        if isinstance(node.func, ast.Attribute):
            s = node.func.value.id + "." + node.func.attr
        else:
            s = node.func.id
            if s in SymbolPass.builtin_typecall_names:
                s = self.handle_builtin_typecall(node)
                if s == "String":
                    is_string = True
                elif s in ("tuple", "list", "set"):
                    is_list = True
        if is_list:
            s = "["
        else:
            s += "("
        if len(node.args) > 0:
            self.num_arguments = 0
            for arg in node.args:
                if self.num_arguments > 0:
                    s += ", "
                self.num_arguments += 1
                if isinstance(arg, ast.Constant):
                    value = self.visit(arg)
                    if is_string:
                        value = f'"{value}"'
                elif isinstance(arg, ast.Subscript):
                    value = self.visit(arg.value)
                    value += "["
                    value += self.visit(arg.slice)
                    value += "]"
                elif isinstance(arg, ast.Name):
                    value = arg.id
                elif isinstance(arg, ast.BinOp):
                    value = self.visit_BinOp(arg)
                else:
                    raise Exception(f"Unexpected {arg=}")
                s += f"{value}"
        if is_list:
            s += "]"
        else:
            s += ")"
        return s

    def visit_Subscript(self, node):
        symbol = node.value.id
        scoped_sym = self.scoped_sym(symbol)
        symtype = self.syms.find_type(scoped_sym)
        if node.slice.step is not None:
            raise self.exception(f'Stepped slice not supported')
        if symtype == 'str':
            s = symbol + ".substr("
            slice_lower = self.visit(node.slice.lower)
            s += f'{slice_lower}'
            slice_upper = self.visit(node.slice.upper)
            if isinstance(slice_upper, str) and slice_upper[0] == '-':
                s += f', ({symbol}.size(){slice_upper}-{slice_lower})'
            else:
                s += f', ({slice_upper}-{slice_lower})'
            s += ")"
            return s
        else:
            raise self.exception(f'Unable to use [] on {symbol} which is of type {symtype}')

    def visit(self, node):
        """Visit a node."""
        method = "visit_" + node.__class__.__name__
        visitor = getattr(self, method, self.generic_visit)
        if visitor == self.generic_visit or DEBUG_SHOW_NODES:
            print(f"Going to call {method} {node!r}")
        self.current_node = node  # will be used for easy error reporting
        return visitor(node)

    def generic_visit(self, node):
        """Called if no explicit visitor function exists for a node."""
        s = ""
        is_docstring = False
        maybe_docstring = False
        if isinstance(node, ast.Expr) and self.current_target is None:
            maybe_docstring = True
        for field, value in iter_fields(node):
            if isinstance(value, list):
                if DEBUG_SHOW_NODES:
                    print(f"Iterating {node.__class__.__name__}.{field}")
                for item in value:
                    if isinstance(item, AST):
                        if DEBUG_SHOW_NODES:
                            print(f"Going to visit list item {item.__class__.__name__}")
                        ret = self.visit(item)
                        s = s if ret is None else s + str(ret)
            elif isinstance(value, AST):
                if DEBUG_SHOW_NODES:
                    print(f"Going to visit value {value.__class__.__name__}")
                ret = self.visit(value)
                if ret is not None:
                    if maybe_docstring and isinstance(value, ast.Constant):
                        is_docstring = True
                        ret = ret[1:-1]
                    s += str(ret)
        if len(s) > 0:
            if is_docstring:
                self.output(f"/* {s} */\n", indent=True)
                return True
            else:
                self.output(s, indent=True)
        return None
